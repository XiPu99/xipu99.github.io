<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xi Pu&#39;s blog</title>
    <link>https://xipu99.github.io/cn/</link>
    <description>Recent content on Xi Pu&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Dec 2019 20:28:18 -0800</lastBuildDate>
    
	<atom:link href="https://xipu99.github.io/cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>HashMap浅析</title>
      <link>https://xipu99.github.io/cn/posts/java_hashmap/</link>
      <pubDate>Mon, 30 Dec 2019 20:28:18 -0800</pubDate>
      
      <guid>https://xipu99.github.io/cn/posts/java_hashmap/</guid>
      <description>整理一下最近学到的关于Java的HashMap知识点：
HashMap的核心基于哈希值的桶和链表。
哈希碰撞是指有两个对象因为有相同的哈希值被放入相同的桶中的情况。Java对这种情况的处理是将每个桶的内部结构变成一个链表。在Java 8中，如果一个桶里的链表长度大于8时，HashMap内部会把链表转换成红黑树来提高查找效率。把变为树的阈值取为8的原因是因为一个哈希桶中的元素数量大致是一个泊松分部，当数量超过8时，概率就非常小了。
如果我们使用HashMap的默认构造器，也就是不传入任何参数，那么创建出来的HashMap的初始容量为16，也就是说刚开始会有16个哈希桶，Java会用一个长度为16的数组来表示这些桶。
当我们使用map.put(key, val)这种操作时，Java先调用对象的hashcode()方法计算哈希值，然后根据这个哈希值把对象放入相应的哈希桶中。
为了通过对象的哈希值计算相应哈希桶的下标，我们需要hashcode所有可能的值（-2^31~2^31-1），映射到0~15之间。一个最直接的方法是对哈希值进行取余操作，也就是hashcode%16来得到桶的下标。但是，对负数取余会得到一个负数。其次，取余作为一种计算方法操作效率比较低。
HashMap源码中使用了位运算hashcode &amp;amp; (容量-1) 来计算桶的小标。这个位运算操作本质上就是利用二进制进行取余操作，同时这段源码也解释了为什么HashMap的容量必须为2的幂。
当HashMap里的元素数量超过了一个阈值时，Java会对它进行扩容，新的容量变为原来的两倍，这样做可以减少哈希碰撞。 阈值的值为容量和负载因子的乘积。在扩容的过程中，Java会对HashMap中的元素重新计算哈希值，然后放到扩容后的桶中。
关于HashMap，还有一个非常重要的点就是HashMap是非线程安全的。如果你想要使用线程安全的哈希表实现，可以使用ConcurrentHashMap。至于为什么HashMap不是线程安全的，简单来说是因为扩容时对桶中元素进行移动等读写操作时会造成死循环，具体原因可以参考这篇文章。</description>
    </item>
    
    <item>
      <title>Maven包管理</title>
      <link>https://xipu99.github.io/cn/posts/maven-package-management/</link>
      <pubDate>Sat, 28 Dec 2019 15:10:06 -0800</pubDate>
      
      <guid>https://xipu99.github.io/cn/posts/maven-package-management/</guid>
      <description>最近初步了解了maven和Java的编译过程，做一下知识的总结：
Java编译过程 我们都知道，平时我们在IDE中写的都是源代码，然而我们的电脑其实并“看不懂”源代码，这时候我们就需要一个叫编译器的东西把源代码转换成电脑能看懂的语言，比如说二进制。Java的编译器会把源代码转换成一种叫字节码的东西，这些文件以.class为后缀名，编译好之后通过JVM来运行。然而平时我们在写代码的时候却很少关注过甚至意识到还有这个过程。
我们会把这些.class文件打包成一个.jar文件。这个文件其实本质上是一个.zip文件，只不过Java把后缀名改成了.jar(如果不信的话，你可以试试把一个jar文件的后缀名改成zip，在mac上你可以直接双击解压)。
为什么需要包管理 在日常开发中，我们不可避免的会使用一些第三方库，也就是其他人写的代码。在没有maven这种包管理系统之前，程序员都是手动管理依赖包的，这样的过程十分麻烦，而且容易产生错误。有了maven之后，这种脏活累活就不需要程序员自己去做了。maven会在你的项目的根目录中添加一个叫pom.xml的文件，里面包含了各种跟你项目有关的信息，其中就包括了项目中依赖了哪些包这种信息。
如何解决包冲突 然而，maven不是万能的，有的时候我们会遇到包冲突的问题，也就是在我们的项目中，出现了多个有相同名字，不同版本号的包。
这个时候，maven必须强行选择其中一个版本的包来运行，然后忽略其他版本。这就导致了有时我们会遇到编译报错的问题，因为maven忽略的版本中可能包含了我们项目中所需要的类或方法。
为了解决这个问题，我们必须了解maven是如何进行这个选择的。
如果我们把程序中的依赖关系想象成数据结构中的树的话，maven解决的方法很容易理解，它具体遵守了以下两个原则：
 在依赖树中里根最近的依赖包会被保留 如果两个包和根有相同的距离，那么最先在pom.xml中出现的被保留  所以为了解决包冲突，我们可以直接在依赖树的根部声明一个我们想要保留的包名和它的版本号或者在pom.xml中使用&amp;lt;exclusion&amp;gt;标记.</description>
    </item>
    
  </channel>
</rss>